package algorithm

import "strconv"

/**
经典0-1背包问题
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。
其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

动态规划经典框架
for 状态1 in 状态1所有值
	for 状态2 in 状态2所有值
		dp[状态1][状态2] = 择优(选择1， 选择2)
*/
func Knapsack(N, W int, wt, val []int) int {
	//经典背包问题，求最值，思路往动态规划上靠。
	//动态规划本质其实是穷举，记录下之前的值，避免重复计算。
	//动态规划问题需要思考两个点，1、状态 2、选择。
	//本题的状态其实有两种，背包容量，物品重量
	//本题的选择也有两种，在穷举到某个物品的时候，1、装入 2、不装入
	//根据上面的动态规划经典框架，可以规划一个二维dp，dp[i][k]表示前i个元素在容量为k的情况下的礼物最大值
	//最终返回dp[N][W]即可

	//思考状态转移方程。当前容量下，对于当前物品，其实有要么装入，要么不装入两种选择，不装入的话，毫无疑问有dp[i][k] = dp[i-1][k]
	//如果装入的话，在当前的容量下，一定有dp[i-1][k-wt[i]] + val[i]
	//那么其实有dp[i][k] = max(dp[i-1][k], dp[i-1][k-wt[i]] + val[i])，有了这个状态转移方程之后，则可以开始写代码
	dp := make([][]int, N+1)
	dp[0] = make([]int, W+1)
	for i := 1; i <= N; i++ {
		dp[i] = make([]int, W+1)
		for k := 1; k <= W; k++ {
			//如果当前容量小于当前物品的重量，毫无疑问不能放入
			if k < wt[i-1] {
				dp[i][k] = dp[i-1][k]
			} else {
				dp[i][k] = max(dp[i-1][k], dp[i-1][k-wt[i-1]]+val[i-1])
			}
		}
	}
	return dp[N][W]
}

/**
经典高楼扔鸡蛋问题
你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。
现在确定这栋楼存在楼层 0 <= F <= N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。
现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？
*/
func SuperEggDrop1(K, N int) int {
	//首先理解最坏情况。假设N=7，最原始的方法，鸡蛋从1楼依次线性的往上，直到找到楼层位置。以这种策略，最坏情况应该是丢到7楼也没碎，丢了7次
	//再来理解一下最少。不考虑鸡蛋个数限制，同样是7层楼，我们可以用二分查找，先在4楼丢一次，碎了去2楼，没碎去6楼...
	//以这种策略，最坏情况同样是到第7层还没碎，那么这种策略只需要3次即可找出，比线性扫描的7次要少，所以这就是至少。
	//但是这道题给了鸡蛋个数，那么就不能直接用二分查找，因为鸡蛋可能会不够用
	//依照动态规划的想法，设定一个dp table。 dp(k, n)表示楼层为k鸡蛋为n的最坏情况下的最少次数。
	//那么就有状态转移方程：dp(k, n) = min(dp(k-1, 楼层), dp(k, 楼层)) + 1
	//即如果鸡蛋碎了，则将鸡蛋的个数减1，并向下方的楼层找。如果鸡蛋没碎，那么鸡蛋的个数不变，向上方的楼层找

	//开始写代码
	var dp func(K, N int) int
	//hashMap记录重复的数据
	memo := make(map[string]int)

	dp = func(K, N int) int {
		//如果只有一个鸡蛋，只能线性扫描，那么最坏情况肯定是所有楼层都扫描一遍
		if K == 1 {
			return N
		}
		if N == 0 {
			return 0
		}
		str := strconv.Itoa(K) + "," + strconv.Itoa(N)
		if v, ok := memo[str]; ok {
			return v
		}
		res := 1<<31 - 1
		//穷举所有可能的选择（假设从每一层开始丢鸡蛋）
		/*for i := 1; i <= N; i++ {
			//dp(K-1, N-i)表示鸡蛋碎了，往当前楼层的楼下找
			//dp(K, i-1)表示鸡蛋没碎，往当前楼层的楼上找，倒过来思考，相当于往楼下找
			res = min(res, max(dp(K-1, N-i), dp(K, i-1))+1)
		}*/

		//可以使用二分法代替线性搜索
		l, r := 1, N
		for l <= r {
			mid := l + (r-l)/2
			//碎了
			broken := dp(K-1, mid-1)
			//没碎
			not_broken := dp(K, N-mid)
			if broken > not_broken {
				//鸡蛋碎了，往下继续找
				r = mid - 1
				res = min(res, broken+1)
			} else {
				//鸡蛋没碎，往上继续找
				l = mid + 1
				res = min(res, not_broken+1)
			}
		}
		//计入备忘录
		memo[str] = res
		return res
	}
	return dp(K, N)
}
